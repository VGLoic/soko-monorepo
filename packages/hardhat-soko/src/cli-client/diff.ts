import { createHash } from "node:crypto";

import { StepTracker } from "../cli-ui";
import { LocalStorage } from "../local-storage";
import { toAsyncResult } from "../utils/result";
import { CliError } from "./error";
import { lookForBuildInfoJsonFile } from "./helpers/look-for-build-info-json-file";
import { mapBuildInfoToSokoArtifact } from "./helpers/map-build-info-to-soko-artifact";
import { SokoArtifact } from "@/utils/artifacts-schemas/soko-v0";
import { HARDHAT_COMPILER_OUTPUT_FORMAT } from "@/utils/artifacts-schemas/hardhat-v2";
import {
  FORGE_COMPILER_DEFAULT_OUTPUT_FORMAT,
  FORGE_COMPILER_OUTPUT_WITH_BUILD_INFO_OPTION_FORMAT,
} from "@/utils/artifacts-schemas/forge-v1";

const PARSING_SUCCESS_TEXT: Record<SokoArtifact["origin"]["_format"], string> =
  {
    [HARDHAT_COMPILER_OUTPUT_FORMAT]: "Hardhat compilation artifact detected",
    [FORGE_COMPILER_OUTPUT_WITH_BUILD_INFO_OPTION_FORMAT]:
      "Forge compilation artifact detected",
    [FORGE_COMPILER_DEFAULT_OUTPUT_FORMAT]:
      "Forge compilation artifact detected",
  };

/**
 * This script generates the differences between the artifacts generated by a fresh compilation and the ones of a pulled artifact.
 *
 * The fresh artifacts are represented by the file at `artifacts/build-info/<build info hash>.json`.
 * The `latest` artifacts are represented by the file at `<Soko directory>/<release>/build-info.json`.
 *
 * For each build info file, the script will parse the `output.contracts` object.
 * This object contains as keys the path of a contract file and as values the contracts within it, i.e.
 * ```
 * {
 *  "output": {
 *   "contracts": {
 *      "path/to/foo.sol": {
 *         "Foo": {
 *             "abi": [...],
 *             "devdoc": {...},
 *             "evm": {
 *                "bytecode": {...},
 *                "deployedBytecode": {...},
 *                ...
 *             },
 *             "metadata": "...",
 *             "storageLayout": {...},
 *             "userdoc": {...}
 *         }
 *      },
 *      "path/to/bar.sol": {
 *         "Bar1": {
 *             "abi": [...],
 *             "devdoc": {...},
 *             "evm": {
 *                "bytecode": {...},
 *                "deployedBytecode": {...},
 *                ...
 *             },
 *             "metadata": "...",
 *             "storageLayout": {...},
 *             "userdoc": {...}
 *         },
 *         "Bar2": {
 *             "abi": [...],
 *             "devdoc": {...},
 *             "evm": {
 *                "bytecode": {...},
 *                "deployedBytecode": {...},
 *                ...
 *             },
 *             "metadata": "...",
 *             "storageLayout": {...},
 *             "userdoc": {...}
 *         },
 *      },
 *   }
 * }
 * ```
 *
 * For each contract, a hash is computed based on
 * - stringified abi,
 * - bytecode object,
 * - metadata
 * This hash is stored in a map with the `<file path><separator constant><contract name>` as key.
 *
 * Comparing the two maps, the script will output the differences between the two sets of contracts.
 */
export type Difference = {
  path: string;
  name: string;
  status: "added" | "removed" | "changed";
};

/**
 * Generates the differences between the artifacts generated by a fresh compilation and the ones of a pulled artifact.
 * It consists of the following steps:
 * 1. Check if the target artifact exists locally, if not throw an error
 * 2. Read the build info file of the fresh compilation artifact and generate the contract hashes map
 * 3. Read the build info file of the target artifact and generate the contract hashes map
 * 4. Compare the two maps and generate the differences array
 *
 * @throws CliError if there is an error during the execution of the steps, with user-friendly messages that can be directly shown to the user
 * @param artifactPath The path to the artifact to compare with,
 * @param artifact The artifact to compare with, containing the project and the tag or id of the target artifact
 * @param localStorage The local storage used to persist pulled artifacts
 * @param opts Options for the diff command, currently only supports the debug option to enable more verbose logging
 * @returns The array of differences between the fresh compilation artifact and the target artifact
 */
export async function generateDiffWithTargetRelease(
  artifactPath: string,
  artifact: { project: string; tagOrId: string },
  localStorage: LocalStorage,
  opts: { debug: boolean },
): Promise<Difference[]> {
  const steps = new StepTracker(4);

  // Step 1: Check if target artifact exists locally

  steps.start("Checking local artifact existence...");
  const ensureResult = await toAsyncResult(
    localStorage.ensureProjectSetup(artifact.project),
    { debug: opts.debug },
  );
  if (!ensureResult.success) {
    steps.fail("Failed to setup local storage");
    throw new CliError(
      "Error setting up local storage, is the script not allowed to write to the filesystem? Run with debug mode for more info",
    );
  }

  let type: "tag" | "id" | undefined = undefined;
  const isIdResult = await toAsyncResult(
    localStorage.hasId(artifact.project, artifact.tagOrId),
    { debug: opts.debug },
  );
  if (!isIdResult.success) {
    steps.fail("Failed to check local artifacts");
    throw new CliError(
      "Error checking local storage, is the script not allowed to read from the filesystem? Run with debug mode for more info",
    );
  }
  if (isIdResult.value) {
    type = "id";
  }

  const isTagResult = await toAsyncResult(
    localStorage.hasTag(artifact.project, artifact.tagOrId),
    { debug: opts.debug },
  );
  if (!isTagResult.success) {
    steps.fail("Failed to check local artifacts");
    throw new CliError(
      "Error checking local storage, is the script not allowed to read from the filesystem? Run with debug mode for more info",
    );
  }
  if (isTagResult.value) {
    type = "tag";
  }

  if (!type) {
    steps.fail("Local artifact not found");
    throw new CliError(
      `The artifact "${artifact.project}:${artifact.tagOrId}" has not been found locally. Please, make sure to have the artifact locally before running the diff command. Run with debug mode for more info`,
    );
  }

  steps.succeed("Local artifact found");

  // Step 2: Look for compilation artifact
  steps.start("Looking for compilation artifact...");
  const buildInfoPathResult = await toAsyncResult(
    lookForBuildInfoJsonFile(artifactPath, opts.debug),
  );
  if (!buildInfoPathResult.success) {
    steps.fail("Failed to find compilation artifact");
    // @dev the lookForBuildInfoJsonFile function throws a CliError with a user-friendly message, so we can directly re-throw it here without wrapping it in another error or modifying the message
    throw buildInfoPathResult.error;
  }
  steps.succeed(`Compilation artifact found at ${buildInfoPathResult.value}`);

  // Step 3: Parse the compilation artifact, mapping it to the Soko format
  steps.start("Analyzing compilation artifact...");
  const sokoArtifactParsingResult = await toAsyncResult(
    mapBuildInfoToSokoArtifact(buildInfoPathResult.value, opts.debug),
  );
  if (!sokoArtifactParsingResult.success) {
    steps.fail("Unable to handle the provided compilation artifact");
    // @dev the mapBuildInfoToSokoArtifact function throws an Error with a user-friendly message, so we can directly re-throw it here without wrapping it in another error or modifying the message
    throw sokoArtifactParsingResult.error;
  }
  const sokoArtifact = sokoArtifactParsingResult.value.artifact;
  steps.succeed(PARSING_SUCCESS_TEXT[sokoArtifact.origin._format]);

  const virtualReleaseContractHashesResult = await toAsyncResult(
    generateContractHashes(sokoArtifact),
    { debug: opts.debug },
  );
  if (!virtualReleaseContractHashesResult.success) {
    steps.fail("Failed to analyze compilation artifact");
    throw new CliError(
      "Error generating contract hashes from the fresh compilation artifact. Run with debug mode for more info",
    );
  }
  steps.succeed("Fresh artifact loaded");

  steps.start("Reading target artifact...");
  const artifactContentResult = await toAsyncResult(
    type === "tag"
      ? localStorage.retrieveArtifactByTag(artifact.project, artifact.tagOrId)
      : localStorage.retrieveArtifactById(artifact.project, artifact.tagOrId),
    { debug: opts.debug },
  );
  if (!artifactContentResult.success) {
    steps.fail("Failed to read target artifact");
    throw new CliError(
      "Unable to retrieve the target artifact content, please ensure it exists locally. Run with debug mode for more info",
    );
  }

  const targetReleaseContractHashesResult = await toAsyncResult(
    generateContractHashes(artifactContentResult.value),
    { debug: opts.debug },
  );
  if (!targetReleaseContractHashesResult.success) {
    steps.fail("Failed to analyze target artifact");
    throw new CliError(
      "Error generating contract hashes for the target artifact. Run with debug mode for more info",
    );
  }
  steps.succeed("Target artifact loaded");

  steps.start("Computing differences...");
  const differences: Difference[] = [];
  for (const [
    contractKey,
    contractHash,
  ] of virtualReleaseContractHashesResult.value.entries()) {
    const { contractPath, contractName } = parseKey(contractKey);
    const targetReleaseHash =
      targetReleaseContractHashesResult.value.get(contractKey);
    if (!targetReleaseHash) {
      differences.push({
        path: contractPath,
        name: contractName,
        status: "added",
      });
    } else if (targetReleaseHash !== contractHash) {
      differences.push({
        path: contractPath,
        name: contractName,
        status: "changed",
      });
    }
  }

  for (const contractKey of targetReleaseContractHashesResult.value.keys()) {
    if (!virtualReleaseContractHashesResult.value.has(contractKey)) {
      const { contractPath, contractName } = parseKey(contractKey);
      differences.push({
        path: contractPath,
        name: contractName,
        status: "removed",
      });
    }
  }
  steps.succeed("Differences computed");

  return differences;
}

async function generateContractHashes(
  artifact: SokoArtifact,
): Promise<Map<string, string>> {
  const contractHashes = new Map<string, string>();
  for (const contractPath in artifact.output.contracts) {
    const contracts = artifact.output.contracts[contractPath];
    for (const contractName in contracts) {
      const contract = contracts[contractName];
      if (!contract) {
        throw new Error(
          `Contract ${contractName} in file ${contractPath} is undefined`,
        );
      }
      const hash = hashContract(contract);
      contractHashes.set(formKey(contractPath, contractName), hash);
    }
  }

  return contractHashes;
}

type Contract = SokoArtifact["output"]["contracts"][string][string];
function hashContract(contract: Contract): string {
  const hash = createHash("sha256");

  contract.abi.sort((a, b) => {
    if (a.type !== b.type) {
      return a.type.localeCompare(b.type);
    }
    if (a.type === "function" && b.type === "function") {
      return a.name.localeCompare(b.name);
    }
    if (a.type === "event" && b.type === "event") {
      return a.name.localeCompare(b.name);
    }
    if (a.type === "error" && b.type === "error") {
      return a.name.localeCompare(b.name);
    }
    if (a.type === "constructor" && b.type === "constructor") {
      return 0;
    }
    if (a.type === "fallback" && b.type === "fallback") {
      return 0;
    }
    if (a.type === "receive" && b.type === "receive") {
      return 0;
    }
    return 0;
  });
  for (const abiItem of contract.abi) {
    hash.update(JSON.stringify(abiItem));
  }

  hash.update(contract.evm.bytecode.object);
  hash.update(contract.metadata);

  return hash.digest("hex");
}

const SEPARATOR = "@@@@";
function formKey(contractPath: string, contractName: string): string {
  return `${contractPath}${SEPARATOR}${contractName}`;
}
function parseKey(key: string): { contractPath: string; contractName: string } {
  const [contractPath, contractName] = key.split(SEPARATOR);
  if (!contractPath || !contractName) {
    throw new Error(`Invalid key: ${key}`);
  }
  return { contractPath, contractName };
}
