import { createHash } from "node:crypto";

import { StepTracker } from "../cli-ui";
import { LocalStorage } from "../local-storage";
import {
  ZBuildInfo,
  type CompilerOutputContract,
  toAsyncResult,
  retrieveFreshCompilationArtifact,
} from "../utils";
import { CliError } from "./error";

/**
 * This script generates the differences between the artifacts generated by a fresh compilation and the ones of a pulled artifact.
 *
 * The fresh artifacts are represented by the file at `artifacts/build-info/<build info hash>.json`.
 * The `latest` artifacts are represented by the file at `<Soko directory>/<release>/build-info.json`.
 *
 * For each build info file, the script will parse the `output.contracts` object.
 * This object contains as keys the path of a contract file and as values the contracts within it, i.e.
 * ```
 * {
 *  "output": {
 *   "contracts": {
 *      "path/to/foo.sol": {
 *         "Foo": {
 *             "abi": [...],
 *             "devdoc": {...},
 *             "evm": {
 *                "bytecode": {...},
 *                "deployedBytecode": {...},
 *                ...
 *             },
 *             "metadata": "...",
 *             "storageLayout": {...},
 *             "userdoc": {...}
 *         }
 *      },
 *      "path/to/bar.sol": {
 *         "Bar1": {
 *             "abi": [...],
 *             "devdoc": {...},
 *             "evm": {
 *                "bytecode": {...},
 *                "deployedBytecode": {...},
 *                ...
 *             },
 *             "metadata": "...",
 *             "storageLayout": {...},
 *             "userdoc": {...}
 *         },
 *         "Bar2": {
 *             "abi": [...],
 *             "devdoc": {...},
 *             "evm": {
 *                "bytecode": {...},
 *                "deployedBytecode": {...},
 *                ...
 *             },
 *             "metadata": "...",
 *             "storageLayout": {...},
 *             "userdoc": {...}
 *         },
 *      },
 *   }
 * }
 * ```
 *
 * For each contract, a hash is computed based on
 * - stringified abi,
 * - bytecode object,
 * - metadata
 * This hash is stored in a map with the `<file path><separator constant><contract name>` as key.
 *
 * Comparing the two maps, the script will output the differences between the two sets of contracts.
 */
export type Difference = {
  path: string;
  name: string;
  status: "added" | "removed" | "changed";
};

/**
 * Generates the differences between the artifacts generated by a fresh compilation and the ones of a pulled artifact.
 * It consists of the following steps:
 * 1. Check if the target artifact exists locally, if not throw an error
 * 2. Read the build info file of the fresh compilation artifact and generate the contract hashes map
 * 3. Read the build info file of the target artifact and generate the contract hashes map
 * 4. Compare the two maps and generate the differences array
 *
 * @throws CliError if there is an error during the execution of the steps, with user-friendly messages that can be directly shown to the user
 * @param artifactPath The path to the artifact to compare with,
 * @param artifact The artifact to compare with, containing the project and the tag or id of the target artifact
 * @param localStorage The local storage used to persist pulled artifacts
 * @param opts Options for the diff command, currently only supports the debug option to enable more verbose logging
 * @returns The array of differences between the fresh compilation artifact and the target artifact
 */
export async function generateDiffWithTargetRelease(
  artifactPath: string,
  artifact: { project: string; tagOrId: string },
  localStorage: LocalStorage,
  opts: { debug: boolean },
): Promise<Difference[]> {
  const steps = new StepTracker(4);
  steps.start("Checking local artifact existence...");
  const ensureResult = await toAsyncResult(
    localStorage.ensureProjectSetup(artifact.project),
    { debug: opts.debug },
  );
  if (!ensureResult.success) {
    steps.fail("Failed to setup local storage");
    throw new CliError(
      "Error setting up local storage, is the script not allowed to write to the filesystem? Run with debug mode for more info",
    );
  }

  let type: "tag" | "id" | undefined = undefined;
  const isIdResult = await toAsyncResult(
    localStorage.hasId(artifact.project, artifact.tagOrId),
    { debug: opts.debug },
  );
  if (!isIdResult.success) {
    steps.fail("Failed to check local artifacts");
    throw new CliError(
      "Error checking local storage, is the script not allowed to read from the filesystem? Run with debug mode for more info",
    );
  }
  if (isIdResult.value) {
    type = "id";
  }

  const isTagResult = await toAsyncResult(
    localStorage.hasTag(artifact.project, artifact.tagOrId),
    { debug: opts.debug },
  );
  if (!isTagResult.success) {
    steps.fail("Failed to check local artifacts");
    throw new CliError(
      "Error checking local storage, is the script not allowed to read from the filesystem? Run with debug mode for more info",
    );
  }
  if (isTagResult.value) {
    type = "tag";
  }

  if (!type) {
    steps.fail("Local artifact not found");
    throw new CliError(
      `The artifact "${artifact.project}:${artifact.tagOrId}" has not been found locally. Please, make sure to have the artifact locally before running the diff command. Run with debug mode for more info`,
    );
  }

  steps.succeed("Local artifact found");

  steps.start("Reading fresh compilation artifact...");
  const freshBuildInfoResult = await toAsyncResult(
    retrieveFreshCompilationArtifact(artifactPath),
    { debug: opts.debug },
  );
  if (!freshBuildInfoResult.success) {
    steps.fail("Failed to read compilation artifact");
    throw new CliError(
      "Error retrieving the build info for the compilation. Run with debug mode for more info",
    );
  }

  if (freshBuildInfoResult.value.status === "error") {
    steps.fail("Failed to read compilation artifact");
    throw new CliError(
      `Error retrieving the build info for the compilation: ${freshBuildInfoResult.value.reason}. Run with debug mode for more info`,
    );
  }

  const virtualReleaseContractHashesResult = await toAsyncResult(
    generateContractHashes(freshBuildInfoResult.value.content),
    { debug: opts.debug },
  );
  if (!virtualReleaseContractHashesResult.success) {
    steps.fail("Failed to analyze compilation artifact");
    throw new CliError(
      "Error generating contract hashes from the fresh compilation artifact. Run with debug mode for more info",
    );
  }
  steps.succeed("Fresh artifact loaded");

  steps.start("Reading target artifact...");
  const artifactContentResult = await toAsyncResult(
    type === "tag"
      ? localStorage.retrieveArtifactByTag(artifact.project, artifact.tagOrId)
      : localStorage.retrieveArtifactById(artifact.project, artifact.tagOrId),
    { debug: opts.debug },
  );
  if (!artifactContentResult.success) {
    steps.fail("Failed to read target artifact");
    throw new CliError(
      "Unable to retrieve the target artifact content, please ensure it exists locally. Run with debug mode for more info",
    );
  }

  const targetReleaseContractHashesResult = await toAsyncResult(
    generateContractHashes(JSON.stringify(artifactContentResult.value)),
    { debug: opts.debug },
  );
  if (!targetReleaseContractHashesResult.success) {
    steps.fail("Failed to analyze target artifact");
    throw new CliError(
      "Error generating contract hashes for the target artifact. Run with debug mode for more info",
    );
  }
  steps.succeed("Target artifact loaded");

  steps.start("Computing differences...");
  const differences: Difference[] = [];
  for (const [
    contractKey,
    contractHash,
  ] of virtualReleaseContractHashesResult.value.entries()) {
    const { contractPath, contractName } = parseKey(contractKey);
    const targetReleaseHash =
      targetReleaseContractHashesResult.value.get(contractKey);
    if (!targetReleaseHash) {
      differences.push({
        path: contractPath,
        name: contractName,
        status: "added",
      });
    } else if (targetReleaseHash !== contractHash) {
      differences.push({
        path: contractPath,
        name: contractName,
        status: "changed",
      });
    }
  }

  for (const contractKey of targetReleaseContractHashesResult.value.keys()) {
    if (!virtualReleaseContractHashesResult.value.has(contractKey)) {
      const { contractPath, contractName } = parseKey(contractKey);
      differences.push({
        path: contractPath,
        name: contractName,
        status: "removed",
      });
    }
  }
  steps.succeed("Differences computed");

  return differences;
}

async function generateContractHashes(
  buildInfoContent: string,
): Promise<Map<string, string>> {
  const buildInfoResult = ZBuildInfo.passthrough().safeParse(
    JSON.parse(buildInfoContent),
  );
  if (!buildInfoResult.success) {
    throw new Error(`Invalid build info file: ${buildInfoResult.error}`);
  }

  const contractHashes = new Map<string, string>();
  for (const contractPath in buildInfoResult.data.output.contracts) {
    const contracts = buildInfoResult.data.output.contracts[contractPath];
    for (const contractName in contracts) {
      const contract = contracts[contractName];
      if (!contract) {
        throw new Error(
          `Contract ${contractName} in file ${contractPath} is undefined`,
        );
      }
      const hash = hashContract(contract);
      contractHashes.set(formKey(contractPath, contractName), hash);
    }
  }

  return contractHashes;
}

function hashContract(contract: CompilerOutputContract): string {
  const hash = createHash("sha256");

  contract.abi.sort((a, b) => {
    return a?.name.localeCompare(b?.name);
  });
  for (const abiItem of contract.abi) {
    hash.update(JSON.stringify(abiItem));
  }

  hash.update(contract.evm.bytecode.object);
  hash.update(contract.metadata);

  return hash.digest("hex");
}

const SEPARATOR = "@@@@";
function formKey(contractPath: string, contractName: string): string {
  return `${contractPath}${SEPARATOR}${contractName}`;
}
function parseKey(key: string): { contractPath: string; contractName: string } {
  const [contractPath, contractName] = key.split(SEPARATOR);
  if (!contractPath || !contractName) {
    throw new Error(`Invalid key: ${key}`);
  }
  return { contractPath, contractName };
}
