import z from "zod";
import { JsonSchema } from "../json";

// This file contains the Zod schema for the output JSON structure as output by the Solidity compiler (solc).
// Fields and comments are copied from https://docs.soliditylang.org/en/v0.8.33/using-the-compiler.html#output-description

const ErrorSchema = z.object({
  // Optional: Location within the source file.
  sourceLocation: z
    .object({
      file: z.string(),
      start: z.number(),
      end: z.number(),
    })
    .optional(),
  // Optional: Further locations (e.g. places of conflicting declarations)
  secondarySourceLocations: z
    .array(
      z.object({
        file: z.string(),
        start: z.number(),
        end: z.number(),
        message: z.string().optional(),
      }),
    )
    .optional(),
  // Mandatory: Error type, such as "TypeError", "InternalCompilerError", "Exception", etc.
  // See below for complete list of types.
  type: z.string(),
  // Mandatory: Component where the error originated, such as "general" etc.
  component: z.string(),
  // Mandatory ("error", "warning" or "info", but please note that this may be extended in the future)
  severity: z.string(),
  // Optional: unique code for the cause of the error
  errorCode: z.string().optional(),
  // Mandatory
  message: z.string(),
  // Optional: the message formatted with source location
  formattedMessage: z.string().optional(),
});

const OutputSourceSchema = z.object({
  // Identifier of the source (used in source maps)
  id: z.number(),
  // The AST object
  ast: JsonSchema,
});

// Schema is derived from the documentation https://docs.soliditylang.org/en/develop/abi-spec.html#json
const ComponentSchema = z.unknown();
const EventItemSchema = z.object({
  type: z.literal("event"),
  name: z.string(),
  inputs: z.array(
    z.object({
      name: z.string(),
      type: z.string(),
      components: z.array(ComponentSchema).optional(),
      indexed: z.boolean(),
    }),
  ),
  anonymous: z.boolean(),
});
const ErrorItemSchema = z.object({
  type: z.literal("error"),
  name: z.string(),
  inputs: z.array(
    z.object({
      name: z.string(),
      type: z.string(),
      components: z.array(ComponentSchema).optional(),
    }),
  ),
});
const ItemOutputInputSchema = z.object({
  name: z.string(),
  type: z.string(),
  components: z.array(ComponentSchema).optional(),
});
const FunctionItemSchema = z.object({
  type: z.literal("function"),
  name: z.string(),
  inputs: z.array(ItemOutputInputSchema),
  outputs: z.array(ItemOutputInputSchema).optional(),
  stateMutability: z.enum(["pure", "view", "nonpayable", "payable"]),
});
const ConstructorItemSchema = z.object({
  type: z.literal("constructor"),
  inputs: z.array(ItemOutputInputSchema),
  stateMutability: z.enum(["pure", "view", "nonpayable", "payable"]),
});
const FallbackItemSchema = z.object({
  type: z.literal("fallback"),
  stateMutability: z.enum(["pure", "view", "nonpayable", "payable"]),
});
const ReceiveItemSchema = z.object({
  type: z.literal("receive"),
  stateMutability: z.enum(["pure", "view", "nonpayable", "payable"]),
});
export const AbiItemSchema = z.discriminatedUnion("type", [
  EventItemSchema,
  ErrorItemSchema,
  FunctionItemSchema,
  ConstructorItemSchema,
  FallbackItemSchema,
  ReceiveItemSchema,
]);

export const BytecodeSchema = z.object({
  // Debugging data at the level of functions.
  functionDebugData: JsonSchema.optional(),
  // The bytecode as a hex string.
  object: z.string(),
  // Opcodes list (string)
  opcodes: z.string().optional(),
  // The source mapping as a string. See the source mapping definition.
  sourceMap: z.string().optional(),
  // Array of sources generated by the compiler. Currently only
  // contains a single Yul file.
  generatedSources: z.array(JsonSchema).optional(),
  // If given, this is an unlinked object.
  linkReferences: z.record(
    z.string(), // File name
    z.record(
      z.string(), // Library name
      z.array(
        z.object({
          start: z.number(),
          length: z.number(),
        }),
      ),
    ),
  ),
});

export const SolcContractSchema = z.object({
  // The Ethereum Contract ABI. If empty, it is represented as an empty array.
  // See https://docs.soliditylang.org/en/develop/abi-spec.html
  abi: z.array(AbiItemSchema),
  // See the Metadata Output documentation (serialised JSON string)
  metadata: z.string(),
  // User documentation (natspec)
  userdoc: JsonSchema.optional(),
  // Developer documentation (natspec)
  devdoc: JsonSchema.optional(),
  // Intermediate representation before optimization (string)
  ir: z.string().optional(),
  // AST of intermediate representation before optimization
  irAst: JsonSchema.optional(),
  // Intermediate representation after optimization (string)
  irOptimized: z.string().optional(),
  // AST of intermediate representation after optimization
  irOptimizedAst: JsonSchema.optional(),
  // See the Storage Layout documentation.
  storageLayout: JsonSchema.optional(),
  // See the Storage Layout documentation.
  transientStorageLayout: JsonSchema.optional(),
  // EVM-related outputs
  evm: z.object({
    // Assembly (string)
    assembly: z.string().optional(),
    // Old-style assembly (object)
    legacyAssembly: JsonSchema.optional(),
    // Bytecode and related details.
    bytecode: BytecodeSchema,
    deployedBytecode: BytecodeSchema.extend({
      immutableReferences: JsonSchema.optional(),
    }),
    // The list of function hashes
    methodIdentifiers: z.record(z.string(), z.string()).optional(),
    // Function gas estimates
    gasEstimates: z
      .object({
        creation: z.record(z.string(), z.string()).optional(),
        external: z.record(z.string(), z.string()).optional(),
        internal: z.record(z.string(), z.string()).optional(),
      })
      .optional(),
  }),
});

/**
 * This is the schema for the output JSON structure as output by the Solidity compiler (solc).
 * Fields and comments are copied from https://docs.soliditylang.org/en/v0.8.33/using-the-compiler.html#output-description
 *
 * Taken at version v0.8.33
 */
export const SolcJsonOutputSchema = z.object({
  // Optional: not present if no errors/warnings/infos were encountered
  errors: z.array(ErrorSchema).optional(),
  // This contains the file-level outputs.
  // It can be limited/filtered by the outputSelection settings.
  sources: z.record(z.string(), OutputSourceSchema).optional(),
  // This contains the contract-level outputs.
  // It can be limited/filtered by the outputSelection settings.
  contracts: z.record(
    z.string(), // Source file name
    z.record(
      z.string(), // Contract name
      SolcContractSchema,
    ),
  ),
});
