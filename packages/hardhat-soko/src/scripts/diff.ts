import { createHash } from "node:crypto";
import {
  ZBuildInfo,
  type CompilerOutputContract,
  toAsyncResult,
  retrieveFreshCompilationArtifact,
  ScriptError,
} from "../utils";
import { LocalStorage } from "../local-storage";

/**
 * This script generates the differences between the artifacts generated by a fresh compilation and the ones of a pulled artifact.
 *
 * The fresh artifacts are represented by the file at `artifacts/build-info/<build info hash>.json`.
 * The `latest` artifacts are represented by the file at `<Soko directory>/<release>/build-info.json`.
 *
 * For each build info file, the script will parse the `output.contracts` object.
 * This object contains as keys the path of a contract file and as values the contracts within it, i.e.
 * ```
 * {
 *  "output": {
 *   "contracts": {
 *      "path/to/foo.sol": {
 *         "Foo": {
 *             "abi": [...],
 *             "devdoc": {...},
 *             "evm": {
 *                "bytecode": {...},
 *                "deployedBytecode": {...},
 *                ...
 *             },
 *             "metadata": "...",
 *             "storageLayout": {...},
 *             "userdoc": {...}
 *         }
 *      },
 *      "path/to/bar.sol": {
 *         "Bar1": {
 *             "abi": [...],
 *             "devdoc": {...},
 *             "evm": {
 *                "bytecode": {...},
 *                "deployedBytecode": {...},
 *                ...
 *             },
 *             "metadata": "...",
 *             "storageLayout": {...},
 *             "userdoc": {...}
 *         },
 *         "Bar2": {
 *             "abi": [...],
 *             "devdoc": {...},
 *             "evm": {
 *                "bytecode": {...},
 *                "deployedBytecode": {...},
 *                ...
 *             },
 *             "metadata": "...",
 *             "storageLayout": {...},
 *             "userdoc": {...}
 *         },
 *      },
 *   }
 * }
 * ```
 *
 * For each contract, a hash is computed based on
 * - stringified abi,
 * - bytecode object,
 * - metadata
 * This hash is stored in a map with the `<file path><separator constant><contract name>` as key.
 *
 * Comparing the two maps, the script will output the differences between the two sets of contracts.
 */
type Difference = {
  path: string;
  name: string;
  status: "added" | "removed" | "changed";
};
export async function generateDiffWithTargetRelease(
  artifactPath: string,
  artifact: { project: string; tagOrId: string },
  opts: { debug?: boolean } = {},
  localStorage: LocalStorage,
): Promise<Difference[]> {
  let type: "tag" | "id" | undefined = undefined;
  const isIdResult = await toAsyncResult(
    localStorage.hasId(artifact.project, artifact.tagOrId),
    { debug: opts.debug },
  );
  if (!isIdResult.success) {
    throw new ScriptError(
      `Error checking if the artifact is an ID: ${isIdResult.error}`,
    );
  }
  if (isIdResult.value) {
    type = "id";
  }

  const isTagResult = await toAsyncResult(
    localStorage.hasTag(artifact.project, artifact.tagOrId),
    { debug: opts.debug },
  );
  if (!isTagResult.success) {
    throw new ScriptError(
      `Error checking if the artifact is a tag: ${isTagResult.error}`,
    );
  }
  if (isTagResult.value) {
    type = "tag";
  }

  if (!type) {
    throw new ScriptError(
      `The artifact "${artifact.project}:${artifact.tagOrId}" has not been found locally. Please, make sure to have the artifact locally before running the diff command.`,
    );
  }

  const freshBuildInfoResult = await toAsyncResult(
    retrieveFreshCompilationArtifact(artifactPath),
  );
  if (!freshBuildInfoResult.success) {
    if (opts.debug) {
      console.error(
        `Error retrieving the build info for the compilation: ${freshBuildInfoResult.error}`,
      );
    }
    throw new ScriptError(
      `Error retrieving the build info for the compilation.`,
    );
  }

  if (freshBuildInfoResult.value.status === "error") {
    throw new ScriptError(
      `Error retrieving the build info for the compilation: ${freshBuildInfoResult.value.reason}`,
    );
  }

  const virtualReleaseContractHashesResult = await toAsyncResult(
    generateContractHashes(freshBuildInfoResult.value.content),
    opts,
  );
  if (!virtualReleaseContractHashesResult.success) {
    throw new Error(
      `Error generating virtual release contract hashes: ${virtualReleaseContractHashesResult.error}`,
    );
  }

  const artifactContentResult = await toAsyncResult(
    type === "tag"
      ? localStorage.retrieveArtifactByTag(artifact.project, artifact.tagOrId)
      : localStorage.retrieveArtifactById(artifact.project, artifact.tagOrId),
    opts,
  );
  if (!artifactContentResult.success) {
    throw new Error(
      `Unable to retrieve the artifact content: ${artifactContentResult.error}`,
    );
  }

  const targetReleaseContractHashesResult = await toAsyncResult(
    generateContractHashes(JSON.stringify(artifactContentResult.value)),
    opts,
  );
  if (!targetReleaseContractHashesResult.success) {
    throw new Error(
      `Error generating target release contract hashes: ${targetReleaseContractHashesResult.error}`,
    );
  }

  const differences: Difference[] = [];
  for (const [
    contractKey,
    contractHash,
  ] of virtualReleaseContractHashesResult.value.entries()) {
    const { contractPath, contractName } = parseKey(contractKey);
    const targetReleaseHash =
      targetReleaseContractHashesResult.value.get(contractKey);
    if (!targetReleaseHash) {
      differences.push({
        path: contractPath,
        name: contractName,
        status: "added",
      });
    } else if (targetReleaseHash !== contractHash) {
      differences.push({
        path: contractPath,
        name: contractName,
        status: "changed",
      });
    }
  }

  for (const contractKey of targetReleaseContractHashesResult.value.keys()) {
    if (!virtualReleaseContractHashesResult.value.has(contractKey)) {
      const { contractPath, contractName } = parseKey(contractKey);
      differences.push({
        path: contractPath,
        name: contractName,
        status: "removed",
      });
    }
  }

  return differences;
}

async function generateContractHashes(
  buildInfoContent: string,
): Promise<Map<string, string>> {
  const buildInfoResult = ZBuildInfo.passthrough().safeParse(
    JSON.parse(buildInfoContent),
  );
  if (!buildInfoResult.success) {
    throw new Error(`Invalid build info file: ${buildInfoResult.error}`);
  }

  const contractHashes = new Map<string, string>();
  for (const contractPath in buildInfoResult.data.output.contracts) {
    const contracts = buildInfoResult.data.output.contracts[contractPath];
    for (const contractName in contracts) {
      const contract = contracts[contractName];
      if (!contract) {
        throw new Error(
          `Contract ${contractName} in file ${contractPath} is undefined`,
        );
      }
      const hash = hashContract(contract);
      contractHashes.set(formKey(contractPath, contractName), hash);
    }
  }

  return contractHashes;
}

function hashContract(contract: CompilerOutputContract): string {
  const hash = createHash("sha256");

  contract.abi.sort((a, b) => {
    return a?.name.localeCompare(b?.name);
  });
  for (const abiItem of contract.abi) {
    hash.update(JSON.stringify(abiItem));
  }

  hash.update(contract.evm.bytecode.object);
  hash.update(contract.metadata);

  return hash.digest("hex");
}

const SEPARATOR = "@@@@";
function formKey(contractPath: string, contractName: string): string {
  return `${contractPath}${SEPARATOR}${contractName}`;
}
function parseKey(key: string): { contractPath: string; contractName: string } {
  const [contractPath, contractName] = key.split(SEPARATOR);
  if (!contractPath || !contractName) {
    throw new Error(`Invalid key: ${key}`);
  }
  return { contractPath, contractName };
}
