import { HardhatRuntimeEnvironment } from "hardhat/types";
import { DeployFunction } from "hardhat-deploy/types";
import { project } from "../.soko-typings";
import { verifyContract } from "../scripts/utils";
import { ethers } from "ethers";

/**
 * This deployment script deploys the Counter contract targeting a specific release.
 *
 * The compilation artifacts are retrieved from the Soko project registry for the specified release.
 * The artifacts are **frozen** at the time of the release, ensuring consistent deployments.
 * Local modifications to the contract source code or any new compilation, releases etc.. will not affect this deployment.
 *
 * The `IncrementOracle` contract is deployed first, followed by the `Counter` contract which links to it.
 * The deployment is done using `hardhat-deploy`.
 *
 * This script relies on typings generated by Soko for the project "doubtful-counter".
 * The assumed commands that have been run prior to this deployment are:
 *  - `npx hardhat soko pull` to pull the project from the Soko registry,
 *  - `npx hardhat soko typings` to generate the typings for the project.
 */

const TARGET_RELEASE = "v1.0.1";

const deployCounter: DeployFunction = async function (
  hre: HardhatRuntimeEnvironment,
) {
  const { deployer } = await hre.getNamedAccounts();

  const balance = await hre.ethers.provider.getBalance(deployer);

  console.log("Deploying contracts with account: ", {
    address: deployer,
    balance: ethers.formatEther(balance),
  });

  // Get project utilities for the target release
  const projectUtils = project("doubtful-counter").tag(TARGET_RELEASE);

  // Get compilation artifact (build info) for the target release
  const compilationArtifact = await projectUtils
    .getCompilationArtifact()
    .catch((error) => {
      console.error("Error getting build info", error);
      process.exit(1);
    });

  // Get `IncrementOracle` artifact for the target release and deploy it
  const incrementOracleArtifact = await projectUtils.getContractArtifact(
    "src/IncrementOracle.sol:IncrementOracle",
  );
  const incrementOracleDeployment = await hre.deployments.deploy(
    `IncrementOracle@${TARGET_RELEASE}`,
    {
      contract: {
        abi: incrementOracleArtifact.abi,
        bytecode: incrementOracleArtifact.evm.bytecode.object,
        metadata: incrementOracleArtifact.metadata,
      },
      from: deployer,
      log: true,
    },
  );

  if (hre.network.verify) {
    await verifyContract({
      address: incrementOracleDeployment.address,
      compilationInput: compilationArtifact.input,
      compilerVersion: compilationArtifact.solcLongVersion,
      sourceName: "src/IncrementOracle.sol",
      contractName: "IncrementOracle",
    });
  }

  // Get `Counter` artifact for the target release and deploy it
  const counterArtifact = await projectUtils.getContractArtifact(
    "src/Counter.sol:Counter",
  );
  const counterDeployment = await hre.deployments.deploy(
    `Counter@${TARGET_RELEASE}`,
    {
      contract: {
        abi: counterArtifact.abi,
        bytecode: counterArtifact.evm.bytecode.object,
        metadata: counterArtifact.metadata,
      },
      libraries: {
        "src/IncrementOracle.sol:IncrementOracle":
          incrementOracleDeployment.address,
      },
      from: deployer,
      log: true,
    },
  );

  if (hre.network.verify) {
    await verifyContract({
      address: counterDeployment.address,
      compilationInput: compilationArtifact.input,
      compilerVersion: compilationArtifact.solcLongVersion,
      sourceName: "src/Counter.sol",
      contractName: "Counter",
      libraries: [
        {
          address: incrementOracleDeployment.address,
          sourceName: "src/IncrementOracle.sol",
          contractName: "IncrementOracle",
        },
      ],
    });
  }
};

export default deployCounter;
